
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>nanostore: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arthur-debert/nanostore/nanostore/api.go (100.0%)</option>
				
				<option value="file1">github.com/arthur-debert/nanostore/nanostore/internal/engine/id_resolver.go (90.3%)</option>
				
				<option value="file2">github.com/arthur-debert/nanostore/nanostore/internal/engine/migrations.go (80.0%)</option>
				
				<option value="file3">github.com/arthur-debert/nanostore/nanostore/internal/engine/queries.go (75.0%)</option>
				
				<option value="file4">github.com/arthur-debert/nanostore/nanostore/internal/engine/store.go (82.1%)</option>
				
				<option value="file5">github.com/arthur-debert/nanostore/nanostore/store.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package nanostore

// Store defines the public interface for the document store
type Store interface {
        // List returns documents based on the provided options
        // The returned documents include generated user-facing IDs
        List(opts ListOptions) ([]Document, error)

        // Add creates a new document with the given title and optional parent
        // Returns the UUID of the created document
        Add(title string, parentID *string) (string, error)

        // Update modifies an existing document
        Update(id string, updates UpdateRequest) error

        // SetStatus changes the status of a document
        SetStatus(id string, status Status) error

        // ResolveUUID converts a user-facing ID (e.g., "1.2.c3") to a UUID
        ResolveUUID(userFacingID string) (string, error)

        // Delete removes a document and optionally its children
        // If cascade is true, all child documents are also deleted
        // If cascade is false and the document has children, an error is returned
        Delete(id string, cascade bool) error

        // Close releases any resources held by the store
        Close() error
}

// New creates a new Store instance connected to the given database path
// Use ":memory:" for an in-memory database (useful for testing)
func New(dbPath string) (Store, error) <span class="cov8" title="1">{
        return newStore(dbPath)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package engine

import (
        "database/sql"
        "fmt"
        "strings"
)

// idPart represents a parsed component of a hierarchical ID
type idPart struct {
        status string
        offset int
}

// ResolveUUID converts a user-facing ID to a UUID using optimized queries
// Handles hierarchical IDs like "1", "c2", "1.2", "1.c3" with a single query
func (s *store) ResolveUUID(userFacingID string) (string, error) <span class="cov8" title="1">{
        // Validate input doesn't contain SQL injection attempts
        if strings.ContainsAny(userFacingID, "'\"`;\\") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid ID format: contains illegal characters")
        }</span>

        // Split the ID by dots to handle hierarchical IDs
        <span class="cov8" title="1">parts := strings.Split(userFacingID, ".")

        // Parse all parts first to validate format
        parsedParts := make([]idPart, len(parts))

        for i, part := range parts </span><span class="cov8" title="1">{
                // Extract status and number from the part
                var status string
                var number int

                if strings.HasPrefix(part, "c") </span><span class="cov8" title="1">{
                        status = "completed"
                        consumed, err := fmt.Sscanf(part[1:], "%d", &amp;number)
                        if err != nil || consumed != 1 || len(part[1:]) != len(fmt.Sprintf("%d", number)) </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("invalid ID format: %s", part)
                        }</span>
                } else<span class="cov8" title="1"> {
                        status = "pending"
                        consumed, err := fmt.Sscanf(part, "%d", &amp;number)
                        if err != nil || consumed != 1 || len(part) != len(fmt.Sprintf("%d", number)) </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("invalid ID format: %s", part)
                        }</span>
                }

                // Validate number is positive
                <span class="cov8" title="1">if number &lt; 1 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("invalid ID format: number must be positive")
                }</span>

                <span class="cov8" title="1">parsedParts[i] = idPart{
                        status: status,
                        offset: number - 1, // Convert to 0-based offset
                }</span>
        }

        // Choose the appropriate query based on depth
        <span class="cov8" title="1">var query string
        var args []interface{}
        var err error

        switch len(parts) </span>{
        case 1:<span class="cov8" title="1">
                // Simple root document
                query, err = loadQuery("queries/resolve_path_optimized.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">args = []interface{}{parsedParts[0].status, parsedParts[0].offset}</span>

        case 2:<span class="cov8" title="1">
                // Two-level hierarchy
                query, err = loadQuery("queries/resolve_hierarchical_2.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">args = []interface{}{
                        parsedParts[0].status, parsedParts[0].offset,
                        parsedParts[1].status, parsedParts[1].offset,
                }</span>

        case 3:<span class="cov8" title="1">
                // Three-level hierarchy
                query, err = loadQuery("queries/resolve_hierarchical_3.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">args = []interface{}{
                        parsedParts[0].status, parsedParts[0].offset,
                        parsedParts[1].status, parsedParts[1].offset,
                        parsedParts[2].status, parsedParts[2].offset,
                }</span>

        default:<span class="cov8" title="1">
                // For deeper nesting, fall back to the original iterative approach
                // This is a deliberate design choice: most applications use &lt;3 levels of hierarchy,
                // and optimizing for this common case with single-query resolution provides better
                // performance for the vast majority of use cases. The tradeoff of N queries for
                // N-level deep hierarchies (where N &gt; 3) is acceptable given their rarity.
                return s.resolveUUIDIterative(userFacingID, parsedParts)</span>
        }

        // Execute the single query
        <span class="cov8" title="1">var uuid string
        err = s.db.QueryRow(query, args...).Scan(&amp;uuid)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return "", fmt.Errorf("document not found for ID: %s", userFacingID)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to resolve ID: %w", err)
        }</span>

        <span class="cov8" title="1">return uuid, nil</span>
}

// resolveUUIDIterative is the fallback for very deep hierarchies (4+ levels)
func (s *store) resolveUUIDIterative(userFacingID string, parts []idPart) (string, error) <span class="cov8" title="1">{
        // Start with root documents
        currentParentUUID := sql.NullString{Valid: false}
        var finalUUID string

        for i, part := range parts </span><span class="cov8" title="1">{
                // Query to find the document at this level
                query, err := loadQuery("queries/resolve_id.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">var uuid string
                var scanErr error

                if currentParentUUID.Valid </span><span class="cov8" title="1">{
                        // Looking for a child document
                        scanErr = s.db.QueryRow(query, currentParentUUID.String, currentParentUUID.String, part.status, part.offset).Scan(&amp;uuid)
                }</span> else<span class="cov8" title="1"> {
                        // Looking for a root document
                        scanErr = s.db.QueryRow(query, nil, nil, part.status, part.offset).Scan(&amp;uuid)
                }</span>

                <span class="cov8" title="1">if scanErr == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("document not found for ID: %s", userFacingID)
                }</span> else<span class="cov8" title="1"> if scanErr != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to resolve ID: %w", scanErr)
                }</span>

                // Update parent for next iteration
                <span class="cov8" title="1">currentParentUUID = sql.NullString{String: uuid, Valid: true}

                // If this is the last part, this is our final UUID
                if i == len(parts)-1 </span><span class="cov8" title="1">{
                        finalUUID = uuid
                }</span>
        }

        <span class="cov8" title="1">return finalUUID, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package engine

import (
        "fmt"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
)

// migrate runs all pending migrations
func (s *store) migrate() error <span class="cov8" title="1">{
        // Get current version
        currentVersion, err := s.getCurrentVersion()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current version: %w", err)
        }</span>

        // Get all migration files
        <span class="cov8" title="1">entries, err := sqlFiles.ReadDir("sql/schema")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read schema directory: %w", err)
        }</span>

        // Sort migration files by version number
        <span class="cov8" title="1">var migrations []string
        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".sql") </span><span class="cov8" title="1">{
                        migrations = append(migrations, entry.Name())
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(migrations)

        // Apply migrations
        for _, migration := range migrations </span><span class="cov8" title="1">{
                // Extract version number from filename (e.g., "001_initial.sql" -&gt; 1)
                parts := strings.Split(migration, "_")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">version, err := strconv.Atoi(parts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid migration filename %s: %w", migration, err)
                }</span>

                <span class="cov8" title="1">if version &lt;= currentVersion </span><span class="cov8" title="1">{
                        continue</span> // Skip already applied migrations
                }

                // Read and execute migration
                <span class="cov8" title="1">content, err := sqlFiles.ReadFile(filepath.Join("sql/schema", migration))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read migration %s: %w", migration, err)
                }</span>

                <span class="cov8" title="1">if _, err := s.db.Exec(string(content)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply migration %s: %w", migration, err)
                }</span>

                // Update version
                <span class="cov8" title="1">if err := s.updateVersion(version); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update version after %s: %w", migration, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getCurrentVersion returns the current schema version
func (s *store) getCurrentVersion() (int, error) <span class="cov8" title="1">{
        var version int
        err := s.db.QueryRow("SELECT COALESCE(MAX(version), 0) FROM schema_version").Scan(&amp;version)
        if err != nil </span><span class="cov8" title="1">{
                // Table doesn't exist yet, this is fine
                return 0, nil
        }</span>
        <span class="cov8" title="1">return version, nil</span>
}

// updateVersion records a new schema version
func (s *store) updateVersion(version int) error <span class="cov8" title="1">{
        _, err := s.db.Exec(
                "INSERT INTO schema_version (version, applied_at) VALUES (?, strftime('%s', 'now'))",
                version,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package engine

import (
        "fmt"
        "path/filepath"
)

// loadQuery loads a SQL query from the embedded filesystem
func loadQuery(filename string) (string, error) <span class="cov8" title="1">{
        content, err := sqlFiles.ReadFile(filepath.Join("sql", filename))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to load query %s: %w", filename, err)
        }</span>
        <span class="cov8" title="1">return string(content), nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package engine

import (
        "database/sql"
        "embed"
        "fmt"
        "strings"
        "time"

        "github.com/arthur-debert/nanostore/nanostore/types"
        "github.com/google/uuid"
        _ "github.com/mattn/go-sqlite3"
)

//go:embed all:sql
var sqlFiles embed.FS

// store implements the Store interface
type store struct {
        db *sql.DB
}

// New creates a new store instance.
// Returns the concrete store type since we can't import the Engine interface
// from the parent package (would cause circular dependency).
func New(dbPath string) (*store, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Enable foreign keys
        <span class="cov8" title="1">if _, err := db.Exec("PRAGMA foreign_keys = ON"); err != nil </span><span class="cov8" title="1">{
                _ = db.Close()
                return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
        }</span>

        <span class="cov8" title="1">s := &amp;store{db: db}

        // Run migrations
        if err := s.migrate(); err != nil </span><span class="cov0" title="0">{
                _ = db.Close()
                return nil, fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}

// Close releases database resources
func (s *store) Close() error <span class="cov8" title="1">{
        return s.db.Close()
}</span>

// Add creates a new document
func (s *store) Add(title string, parentID *string) (string, error) <span class="cov8" title="1">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = tx.Rollback() }</span>() // Rollback is a no-op if tx has been committed

        <span class="cov8" title="1">id := uuid.New().String()
        now := time.Now().Unix()

        query, err := loadQuery("queries/insert_document.sql")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">_, err = tx.Exec(query, id, title, "", "pending", parentID, now, now)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to insert document: %w", err)
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return id, nil</span>
}

// Update modifies an existing document
func (s *store) Update(id string, updates types.UpdateRequest) error <span class="cov8" title="1">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = tx.Rollback() }</span>() // Rollback is a no-op if tx has been committed

        // If parent is being updated, check for circular references
        <span class="cov8" title="1">if updates.ParentID != nil </span><span class="cov8" title="1">{
                // Empty string means "make root", which is always safe
                if *updates.ParentID != "" </span><span class="cov8" title="1">{
                        // First check that we're not setting a document as its own parent
                        if *updates.ParentID == id </span><span class="cov8" title="1">{
                                return fmt.Errorf("cannot set document as its own parent")
                        }</span>

                        // Check if this would create a circular reference
                        <span class="cov8" title="1">checkQuery, err := loadQuery("queries/check_circular_reference.sql")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">var wouldBeCircular bool
                        err = tx.QueryRow(checkQuery, *updates.ParentID, id).Scan(&amp;wouldBeCircular)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to check for circular reference: %w", err)
                        }</span>

                        <span class="cov8" title="1">if wouldBeCircular </span><span class="cov8" title="1">{
                                return fmt.Errorf("cannot set parent: would create circular reference")
                        }</span>
                }
        }

        // Choose the appropriate update query
        <span class="cov8" title="1">var query string
        var args []interface{}

        if updates.ParentID != nil </span><span class="cov8" title="1">{
                // Use the query that handles parent updates
                query, err = loadQuery("queries/update_document_with_parent.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Pass parent value for CASE statement evaluation
                <span class="cov8" title="1">args = []interface{}{updates.Title, updates.Body, *updates.ParentID, id}</span>
        } else<span class="cov8" title="1"> {
                // Use the simpler query when parent is not being updated
                query, err = loadQuery("queries/update_document.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">args = []interface{}{updates.Title, updates.Body, id}</span>
        }

        // Execute the update
        <span class="cov8" title="1">result, err := tx.Exec(query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update document: %w", err)
        }</span>

        <span class="cov8" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rows == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetStatus changes the status of a document
func (s *store) SetStatus(id string, status types.Status) error <span class="cov8" title="1">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = tx.Rollback() }</span>() // Rollback is a no-op if tx has been committed

        <span class="cov8" title="1">query, err := loadQuery("queries/set_status.sql")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert Status to string for SQL query
        <span class="cov8" title="1">result, err := tx.Exec(query, string(status), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update status: %w", err)
        }</span>

        <span class="cov8" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rows == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// List returns documents based on options
func (s *store) List(opts types.ListOptions) ([]types.Document, error) <span class="cov8" title="1">{
        // If we have filters, we need to use the templated query
        if hasFilters(opts) </span><span class="cov8" title="1">{
                return s.listWithFilters(opts)
        }</span>

        // No filters - use the simple query
        <span class="cov8" title="1">query, err := loadQuery("queries/list.sql")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := s.db.Query(query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to list documents: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = rows.Close() }</span>()

        // Using the shared Document type
        <span class="cov8" title="1">var results []types.Document
        for rows.Next() </span><span class="cov8" title="1">{
                var (
                        uuid         string
                        userFacingID string
                        title        string
                        body         string
                        status       string
                        parentUUID   sql.NullString
                        createdAt    int64
                        updatedAt    int64
                )

                err := rows.Scan(&amp;uuid, &amp;userFacingID, &amp;title, &amp;body, &amp;status, &amp;parentUUID, &amp;createdAt, &amp;updatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                // Build Document using the shared type
                <span class="cov8" title="1">doc := types.Document{
                        UUID:         uuid,
                        UserFacingID: userFacingID,
                        Title:        title,
                        Body:         body,
                        Status:       types.Status(status), // Convert string to Status type
                        CreatedAt:    time.Unix(createdAt, 0),
                        UpdatedAt:    time.Unix(updatedAt, 0),
                }

                // Handle optional parent UUID
                if parentUUID.Valid </span><span class="cov8" title="1">{
                        doc.ParentUUID = &amp;parentUUID.String
                }</span>

                <span class="cov8" title="1">results = append(results, doc)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// hasFilters checks if any filters are specified
func hasFilters(opts types.ListOptions) bool <span class="cov8" title="1">{
        return len(opts.FilterByStatus) &gt; 0 ||
                opts.FilterByParent != nil ||
                opts.FilterBySearch != ""
}</span>

// listWithFilters handles filtered queries by building the WHERE clauses into the CTEs
func (s *store) listWithFilters(opts types.ListOptions) ([]types.Document, error) <span class="cov8" title="1">{
        // Special case: filtering by a specific parent (not root)
        if opts.FilterByParent != nil &amp;&amp; *opts.FilterByParent != "" </span><span class="cov8" title="1">{
                return s.listBySpecificParent(opts)
        }</span>

        // If we have status or search filters, use the simple filtered query
        // because these filters can break the hierarchical tree structure
        <span class="cov8" title="1">if len(opts.FilterByStatus) &gt; 0 || opts.FilterBySearch != "" </span><span class="cov8" title="1">{
                return s.listSimpleFiltered(opts)
        }</span>

        // Load the base query template for hierarchical queries
        <span class="cov8" title="1">baseQuery, err := loadQuery("queries/list_base.sql")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build WHERE conditions and args
        <span class="cov8" title="1">var conditions []string
        var args []interface{}

        // Filter by status
        if len(opts.FilterByStatus) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := make([]string, len(opts.FilterByStatus))
                for i, status := range opts.FilterByStatus </span><span class="cov0" title="0">{
                        placeholders[i] = "?"
                        args = append(args, string(status))
                }</span>
                <span class="cov0" title="0">conditions = append(conditions, fmt.Sprintf("status IN (%s)", strings.Join(placeholders, ", ")))</span>
        }

        // Filter by search (searches in title and body)
        <span class="cov8" title="1">if opts.FilterBySearch != "" </span><span class="cov0" title="0">{
                searchPattern := "%" + opts.FilterBySearch + "%"
                conditions = append(conditions, "(title LIKE ? OR body LIKE ?)")
                args = append(args, searchPattern, searchPattern)
        }</span>

        // Build the WHERE clause string
        <span class="cov8" title="1">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Handle parent filter for root documents only
        <span class="cov8" title="1">rootWhereClause := whereClause
        childWhereClause := whereClause

        if opts.FilterByParent != nil &amp;&amp; *opts.FilterByParent == "" </span><span class="cov8" title="1">{
                // Filter for root documents only - child_docs should return nothing
                childWhereClause = " AND 1=0" // This ensures no children are selected
        }</span>

        // Replace placeholders in the query
        <span class="cov8" title="1">finalQuery := strings.Replace(baseQuery, "{{ROOT_WHERE_CLAUSE}}", rootWhereClause, 1)
        finalQuery = strings.Replace(finalQuery, "{{CHILD_WHERE_CLAUSE}}", childWhereClause, 1)

        // We need to duplicate args for both root and child clauses
        // Since both CTEs use the same WHERE conditions, we need the args twice
        allArgs := make([]interface{}, 0, len(args)*2)
        allArgs = append(allArgs, args...) // For root_docs
        allArgs = append(allArgs, args...) // For child_docs

        rows, err := s.db.Query(finalQuery, allArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list documents with filters: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = rows.Close() }</span>()

        // Parse results using the same logic as the non-filtered version
        <span class="cov8" title="1">var results []types.Document
        for rows.Next() </span><span class="cov8" title="1">{
                var doc types.Document
                var parentUUID sql.NullString
                var createdUnix, updatedUnix int64

                err := rows.Scan(
                        &amp;doc.UUID,
                        &amp;doc.UserFacingID,
                        &amp;doc.Title,
                        &amp;doc.Body,
                        &amp;doc.Status,
                        &amp;parentUUID,
                        &amp;createdUnix,
                        &amp;updatedUnix,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document: %w", err)
                }</span>

                // Convert nullable parent UUID
                <span class="cov8" title="1">if parentUUID.Valid </span><span class="cov0" title="0">{
                        doc.ParentUUID = &amp;parentUUID.String
                }</span>

                // Convert Unix timestamps to time.Time
                <span class="cov8" title="1">doc.CreatedAt = time.Unix(createdUnix, 0)
                doc.UpdatedAt = time.Unix(updatedUnix, 0)

                results = append(results, doc)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating results: %w", err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// listBySpecificParent handles listing direct children of a specific parent
func (s *store) listBySpecificParent(opts types.ListOptions) ([]types.Document, error) <span class="cov8" title="1">{
        // Load the parent-specific query
        baseQuery, err := loadQuery("queries/list_by_parent.sql")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start with parent UUID as first arg
        <span class="cov8" title="1">args := []interface{}{*opts.FilterByParent}

        // Build additional WHERE conditions
        var conditions []string

        // Filter by status
        if len(opts.FilterByStatus) &gt; 0 </span><span class="cov8" title="1">{
                placeholders := make([]string, len(opts.FilterByStatus))
                for i, status := range opts.FilterByStatus </span><span class="cov8" title="1">{
                        placeholders[i] = "?"
                        args = append(args, string(status))
                }</span>
                <span class="cov8" title="1">conditions = append(conditions, fmt.Sprintf("status IN (%s)", strings.Join(placeholders, ", ")))</span>
        }

        // Filter by search
        <span class="cov8" title="1">if opts.FilterBySearch != "" </span><span class="cov8" title="1">{
                searchPattern := "%" + opts.FilterBySearch + "%"
                conditions = append(conditions, "(title LIKE ? OR body LIKE ?)")
                args = append(args, searchPattern, searchPattern)
        }</span>

        // Build additional WHERE clause
        <span class="cov8" title="1">additionalWhere := ""
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                additionalWhere = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Replace placeholder in query
        <span class="cov8" title="1">finalQuery := strings.Replace(baseQuery, "{{ADDITIONAL_WHERE}}", additionalWhere, 1)

        rows, err := s.db.Query(finalQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list children of parent: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = rows.Close() }</span>()

        // Parse results
        <span class="cov8" title="1">var results []types.Document
        for rows.Next() </span><span class="cov8" title="1">{
                var doc types.Document
                var parentUUID sql.NullString
                var createdUnix, updatedUnix int64

                err := rows.Scan(
                        &amp;doc.UUID,
                        &amp;doc.UserFacingID,
                        &amp;doc.Title,
                        &amp;doc.Body,
                        &amp;doc.Status,
                        &amp;parentUUID,
                        &amp;createdUnix,
                        &amp;updatedUnix,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document: %w", err)
                }</span>

                // Convert nullable parent UUID
                <span class="cov8" title="1">if parentUUID.Valid </span><span class="cov8" title="1">{
                        doc.ParentUUID = &amp;parentUUID.String
                }</span>

                // Convert Unix timestamps to time.Time
                <span class="cov8" title="1">doc.CreatedAt = time.Unix(createdUnix, 0)
                doc.UpdatedAt = time.Unix(updatedUnix, 0)

                results = append(results, doc)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating results: %w", err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// listSimpleFiltered handles queries with status/search filters using a simple non-hierarchical approach
func (s *store) listSimpleFiltered(opts types.ListOptions) ([]types.Document, error) <span class="cov8" title="1">{
        // Load the simple filtered query
        baseQuery, err := loadQuery("queries/list_filtered.sql")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build WHERE conditions and args
        <span class="cov8" title="1">var conditions []string
        var args []interface{}

        // Filter by status
        if len(opts.FilterByStatus) &gt; 0 </span><span class="cov8" title="1">{
                placeholders := make([]string, len(opts.FilterByStatus))
                for i, status := range opts.FilterByStatus </span><span class="cov8" title="1">{
                        placeholders[i] = "?"
                        args = append(args, string(status))
                }</span>
                <span class="cov8" title="1">conditions = append(conditions, fmt.Sprintf("status IN (%s)", strings.Join(placeholders, ", ")))</span>
        }

        // Filter by search
        <span class="cov8" title="1">if opts.FilterBySearch != "" </span><span class="cov8" title="1">{
                searchPattern := "%" + opts.FilterBySearch + "%"
                conditions = append(conditions, "(title LIKE ? OR body LIKE ?)")
                args = append(args, searchPattern, searchPattern)
        }</span>

        // Filter by parent (only root documents)
        <span class="cov8" title="1">if opts.FilterByParent != nil &amp;&amp; *opts.FilterByParent == "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "parent_uuid IS NULL")
        }</span>

        // Build WHERE clause
        <span class="cov8" title="1">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                whereClause = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Replace placeholder in query
        <span class="cov8" title="1">finalQuery := strings.Replace(baseQuery, "{{WHERE_CLAUSE}}", whereClause, 1)

        rows, err := s.db.Query(finalQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list with simple filter: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = rows.Close() }</span>()

        // Parse results
        <span class="cov8" title="1">var results []types.Document
        for rows.Next() </span><span class="cov8" title="1">{
                var doc types.Document
                var parentUUID sql.NullString
                var createdUnix, updatedUnix int64

                err := rows.Scan(
                        &amp;doc.UUID,
                        &amp;doc.UserFacingID,
                        &amp;doc.Title,
                        &amp;doc.Body,
                        &amp;doc.Status,
                        &amp;parentUUID,
                        &amp;createdUnix,
                        &amp;updatedUnix,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document: %w", err)
                }</span>

                // Convert nullable parent UUID
                <span class="cov8" title="1">if parentUUID.Valid </span><span class="cov8" title="1">{
                        doc.ParentUUID = &amp;parentUUID.String
                }</span>

                // Convert Unix timestamps to time.Time
                <span class="cov8" title="1">doc.CreatedAt = time.Unix(createdUnix, 0)
                doc.UpdatedAt = time.Unix(updatedUnix, 0)

                results = append(results, doc)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating results: %w", err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// Delete removes a document and optionally its children
func (s *store) Delete(id string, cascade bool) error <span class="cov8" title="1">{
        // Start a transaction
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = tx.Rollback() }</span>()

        // If not cascading, check if the document has children
        <span class="cov8" title="1">if !cascade </span><span class="cov8" title="1">{
                checkQuery, err := loadQuery("queries/check_has_children.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var hasChildren bool
                err = tx.QueryRow(checkQuery, id).Scan(&amp;hasChildren)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check for children: %w", err)
                }</span>

                <span class="cov8" title="1">if hasChildren </span><span class="cov8" title="1">{
                        return fmt.Errorf("cannot delete document with children unless cascade is true")
                }</span>
        }

        // Load the appropriate delete query
        <span class="cov8" title="1">var deleteQuery string
        if cascade </span><span class="cov8" title="1">{
                deleteQuery, err = loadQuery("queries/delete_cascade.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                deleteQuery, err = loadQuery("queries/delete_document.sql")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Execute the delete
        <span class="cov8" title="1">result, err := tx.Exec(deleteQuery, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document: %w", err)
        }</span>

        // Check if any rows were affected
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package nanostore

import (
        "github.com/arthur-debert/nanostore/nanostore/internal/engine"
)

// Engine defines the internal storage engine interface.
// It directly uses the public nanostore types to avoid redundant type definitions.
// This interface is defined here rather than in the engine package to avoid
// circular imports while still maintaining type safety.
type Engine interface {
        List(opts ListOptions) ([]Document, error)
        Add(title string, parentID *string) (string, error)
        Update(id string, updates UpdateRequest) error
        SetStatus(id string, status Status) error
        ResolveUUID(userFacingID string) (string, error)
        Delete(id string, cascade bool) error
        Close() error
}

// storeAdapter wraps the internal engine to implement the public Store interface.
// After eliminating redundant type definitions, this adapter is now a simple
// pass-through that exists solely to:
// 1. Hide the internal engine package from public API users
// 2. Maintain a clean separation between public interface and internal implementation
// All methods are now simple delegations with no type conversions needed.
type storeAdapter struct {
        engine Engine // Using the local Engine interface
}

// newStore creates a new store instance (internal constructor)
func newStore(dbPath string) (Store, error) <span class="cov8" title="1">{
        eng, err := engine.New(dbPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;storeAdapter{engine: eng}, nil</span>
}

// List returns documents based on the provided options
func (s *storeAdapter) List(opts ListOptions) ([]Document, error) <span class="cov8" title="1">{
        // Simple pass-through - no conversion needed!
        return s.engine.List(opts)
}</span>

// Add creates a new document
func (s *storeAdapter) Add(title string, parentID *string) (string, error) <span class="cov8" title="1">{
        return s.engine.Add(title, parentID)
}</span>

// Update modifies an existing document
func (s *storeAdapter) Update(id string, updates UpdateRequest) error <span class="cov8" title="1">{
        // Simple pass-through - no conversion needed!
        return s.engine.Update(id, updates)
}</span>

// SetStatus changes the status of a document
func (s *storeAdapter) SetStatus(id string, status Status) error <span class="cov8" title="1">{
        // Simple pass-through - Status type is now used throughout
        return s.engine.SetStatus(id, status)
}</span>

// ResolveUUID converts a user-facing ID to a UUID
func (s *storeAdapter) ResolveUUID(userFacingID string) (string, error) <span class="cov8" title="1">{
        return s.engine.ResolveUUID(userFacingID)
}</span>

// Delete removes a document and optionally its children
func (s *storeAdapter) Delete(id string, cascade bool) error <span class="cov8" title="1">{
        return s.engine.Delete(id, cascade)
}</span>

// Close releases any resources
func (s *storeAdapter) Close() error <span class="cov8" title="1">{
        return s.engine.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
