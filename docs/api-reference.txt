Nanostore API Reference

1. TypedStore Interface

1.1 Creating a Typed Store

    The primary way to use nanostore is through the TypedStore API, which automatically
    generates configuration from struct tags:
    
        import "github.com/arthur-debert/nanostore/nanostore"
    
        type TaskItem struct {
            nanostore.Document
            Status   string `values:"pending,active,done" prefix:"done=d" default:"pending"`
            Priority string `values:"low,medium,high" prefix:"high=h" default:"medium"`
            ParentID string `dimension:"parent_id,ref"`
            
            // Non-dimension fields
            Description string
            AssignedTo  string
            DueDate     time.Time
        }
        
        store, err := nanostore.NewFromType[TaskItem]("tasks.json")
        if err != nil {
            return err
        }
        defer store.Close()

1.2 TypedStore Interface Methods

    The TypedStore provides type-safe operations:

    type TypedStore[T any] interface {
        Create(title string, data *T) (string, error)
        Get(id string) (*T, error)
        Update(id string, data *T) error
        Delete(id string, cascade bool) error
        DeleteByDimension(filters map[string]interface{}) (int, error)
        DeleteWhere(whereClause string, args ...interface{}) (int, error)
        UpdateByDimension(filters map[string]interface{}, data *T) (int, error)
        UpdateWhere(whereClause string, data *T, args ...interface{}) (int, error)
        Query() *TypedQuery[T]
        Close() error
    }

2. Document Operations

2.1 Creating Documents

    Type-Safe Creation:
    
        task := &TaskItem{
            Status:      "pending",
            Priority:    "high",
            ParentID:    parentID,  // Can be UUID or SimpleID
            Description: "Important task",
            AssignedTo:  "alice",
        }
        
        id, err := store.Create("Task Title", task)
        if err != nil {
            return err
        }
        // Returns user-friendly ID like "h1" (high priority, position 1)

2.2 Updating Documents

    Type-Safe Update:
    
        // Update fields selectively
        task.Status = "done"
        task.Priority = "low"
        task.AssignedTo = "bob"
        
        err := store.Update(id, task)
        if err != nil {
            return err
        }

2.3 Retrieving Documents

    Get Single Document:
    
        task, err := store.Get(id)
        if err != nil {
            return err
        }
        
        fmt.Printf("Task: %s (Status: %s, Priority: %s)\n", 
            task.Title, task.Status, task.Priority)

2.4 Deleting Documents

    Simple Delete:
    
        err := store.Delete(id, false) // Don't cascade to children

    Cascade Delete:
    
        err := store.Delete(id, true) // Delete children too

    Bulk Delete by Dimension:
    
        deletedCount, err := store.DeleteByDimension(map[string]interface{}{
            "status": "done",
        })

3. Type-Safe Querying

3.1 Basic Queries

    Find All Documents:
    
        tasks, err := store.Query().Find()

    Filter by Single Dimension:
    
        activeTasks, err := store.Query().
            Status("active").
            Find()

    Filter by Multiple Dimensions:
    
        urgentTasks, err := store.Query().
            Status("pending").
            Priority("high").
            Find()

3.2 Advanced Querying

    Hierarchical Queries:
    
        // Find all children of a parent
        children, err := store.Query().
            ParentID("1").
            Find()
        
        // Find root-level items (no parent)
        roots, err := store.Query().
            ParentIDNotExists().
            Find()

    Text Search:
    
        searchResults, err := store.Query().
            Search("urgent").
            Status("active").
            Find()

    Ordering:
    
        orderedTasks, err := store.Query().
            Status("active").
            OrderBy("created_at").
            OrderByDesc("priority").
            Find()

    Pagination:
    
        pagedResults, err := store.Query().
            Status("active").
            Limit(10).
            Offset(20).
            Find()

3.3 Query Result Methods

    Find Multiple:
    
        tasks, err := store.Query().Status("active").Find()

    Find First:
    
        task, err := store.Query().
            Priority("high").
            OrderBy("created_at").
            First()

    Check Existence:
    
        hasUrgent, err := store.Query().
            Priority("high").
            Status("pending").
            Exists()

    Count:
    
        count, err := store.Query().
            Status("active").
            Count()

4. Struct Tag Configuration

4.1 Enumerated Dimensions

    Basic Enumerated Dimension:
    
        type Task struct {
            Status string `values:"pending,active,done"`
        }

    With Default Value:
    
        type Task struct {
            Status string `values:"pending,active,done" default:"pending"`
        }

    With Prefixes:
    
        type Task struct {
            Status   string `values:"pending,active,done" prefix:"done=d,active=a" default:"pending"`
            Priority string `values:"low,medium,high" prefix:"high=h,low=l" default:"medium"`
        }

4.2 Hierarchical Dimensions

    Basic Hierarchical Reference:
    
        type Task struct {
            ParentID string `dimension:"parent_id,ref"`
        }

4.3 Non-Dimension Fields

    Regular fields without tags are stored as custom data:
    
        type Task struct {
            nanostore.Document
            
            // Dimension fields
            Status   string `values:"pending,active,done"`
            Priority string `values:"low,medium,high"`
            ParentID string `dimension:"parent_id,ref"`
            
            // Custom data fields (stored with _data. prefix)
            Description string
            AssignedTo  string
            DueDate     time.Time
            Tags        []string
        }

5. ID Resolution

    Convert User ID to Internal UUID:
    
        uuid, err := store.ResolveUUID("1.2") // User-facing ID
        // Returns internal UUID for storage operations

3. Querying and Filtering

3.1 ListOptions Structure

    type ListOptions struct {
        Filters        map[string]interface{}
        FilterBySearch string
        OrderBy        []OrderClause
        Limit          *int
        Offset         *int
    }
    
    type OrderClause struct {
        Column     string
        Descending bool
    }

3.2 Basic Filtering

    Filter by Single Dimension:
    
        opts := nanostore.NewListOptions()
        opts.Filters["status"] = "pending"
        documents, err := store.List(opts)

    Filter by Multiple Dimensions:
    
        opts.Filters["status"] = "active"
        opts.Filters["priority"] = "high"
        documents, err := store.List(opts)

    Filter by Multiple Values (IN operation):
    
        opts.Filters["status"] = []string{"pending", "active"}
        documents, err := store.List(opts)

3.3 Hierarchical Filtering

    Filter by Parent:
    
        opts.Filters["parent_uuid"] = parentUUID
        children, err := store.List(opts)

    Filter Root Documents:
    
        // Documents with no parent (hierarchical roots)
        opts.Filters["parent_uuid"] = nil
        roots, err := store.List(opts)

3.4 Custom Data Filtering

    Filter by Non-Dimension Fields:
    
        opts.Filters["_data.assigned_to"] = "alice"
        opts.Filters["_data.priority_score"] = 10
        documents, err := store.List(opts)

    Date Range Filtering:
    
        startDate := time.Now().AddDate(0, 0, -7)
        endDate := time.Now()
        opts.Filters["created_at"] = startDate
        // Note: Only exact matches supported, not ranges

3.5 Text Search

    Search Title and Body:
    
        opts := nanostore.NewListOptions()
        opts.FilterBySearch = "important meeting"
        results, err := store.List(opts)

    Combine Search with Filters:
    
        opts.FilterBySearch = "urgent"
        opts.Filters["status"] = "pending"
        opts.Filters["_data.assigned_to"] = "alice"
        results, err := store.List(opts)

3.6 Ordering

    Single Column Ordering:
    
        opts.OrderBy = []nanostore.OrderClause{
            {Column: "created_at", Descending: true},
        }

    Multi-Column Ordering:
    
        opts.OrderBy = []nanostore.OrderClause{
            {Column: "priority", Descending: true},     // High priority first
            {Column: "created_at", Descending: false},  // Then by creation time
        }

    Order by Custom Fields:
    
        opts.OrderBy = []nanostore.OrderClause{
            {Column: "_data.due_date", Descending: false},
            {Column: "title", Descending: false},
        }

3.7 Pagination

    Basic Pagination:
    
        limit := 10
        offset := 20
        opts.Limit = &limit
        opts.Offset = &offset
        page, err := store.List(opts)

    First N Results:
    
        limit := 5
        opts.Limit = &limit
        // offset defaults to 0
        topResults, err := store.List(opts)

4. Declarative API (TypedStore)

4.1 Generated Query Methods

    For a dimension defined as:
    
        Status string `values:"pending,active,done" default:"pending"`

    Generated methods:
    
        store.Query().Status("pending")           // Exact match
        store.Query().StatusIn("pending", "active") // Multiple values
        store.Query().StatusNot("done")           // Exclusion
        store.Query().StatusExists()              // Has any value
        store.Query().StatusNotExists()           // Has no value

4.2 Method Chaining

    Complex Queries:
    
        results, err := store.Query().
            Status("pending").
            Priority("high").
            ParentIDExists().              // Has a parent
            Search("urgent").              // Text search
            OrderBy("created_at").         // Sort by creation time
            Limit(10).                     // First 10 results
            Find()                         // Execute query

4.3 Aggregation Methods

    Count Documents:
    
        count, err := store.Query().
            Status("pending").
            Activity("active").
            Count()

    Check Existence:
    
        hasUrgent, err := store.Query().
            Priority("high").
            Status("pending").
            Exists()

    Get First Match:
    
        firstPending, err := store.Query().
            Status("pending").
            OrderBy("created_at").
            First()

4.4 CRUD Operations

    Create with TypedStore:
    
        id, err := store.Create("New Task", &TaskItem{
            Status:      "pending",
            Priority:    "high",
            ParentID:    parentID,
            Description: "Task description",
            AssignedTo:  "alice",
        })

    Update with TypedStore:
    
        task, err := store.Get(id)
        if err != nil {
            return err
        }
        
        task.Status = "done"
        task.Priority = "low"
        err = store.Update(task.UUID, &task)

    Get by ID:
    
        task, err := store.Get("1.2") // User-facing ID
        task, err := store.Get(uuid)  // Internal UUID

5. Configuration

5.1 Dimension Configuration

    Enumerated Dimension:
    
        nanostore.DimensionConfig{
            Name:         "status",
            Type:         nanostore.Enumerated,
            Values:       []string{"pending", "active", "done"},
            Prefixes:     map[string]string{"done": "d", "active": "a"},
            DefaultValue: "pending",
        }

    Hierarchical Dimension:
    
        nanostore.DimensionConfig{
            Name:     "category",
            Type:     nanostore.Hierarchical,
            RefField: "parent_uuid",
        }

5.2 Struct Tag Reference

    Enumerated Dimension Tags:
    
        Status string `values:"pending,done" prefix:"done=d" default:"pending"`
        //             ^values list        ^prefix map     ^default value

    Hierarchical Dimension Tags:
    
        ParentID string `dimension:"parent_id,ref"`
        //               ^dimension name   ^type indicator

    Multiple Prefixes:
    
        Status string `values:"pending,active,done" prefix:"active=a,done=d"`

5.3 Validation

    Configuration Validation:
    
        err := nanostore.ValidateConfig(config)
        if err != nil {
            // Handle validation errors
            return fmt.Errorf("invalid config: %w", err)
        }

    Common Validation Errors:
    - Empty dimension names
    - Duplicate dimension names
    - Invalid default values (not in values list)
    - Prefix conflicts between dimensions
    - Missing RefField for hierarchical dimensions

6. Error Handling

6.1 Common Errors

    Document Not Found:
    
        doc, err := store.Get("nonexistent")
        if errors.Is(err, nanostore.ErrNotFound) {
            // Handle missing document
        }

    Invalid ID Format:
    
        uuid, err := store.ResolveUUID("invalid-id")
        if err != nil {
            // Handle malformed ID
        }

    Validation Errors:
    
        err := store.Update(id, nanostore.UpdateRequest{
            Dimensions: map[string]interface{}{
                "status": "invalid_status", // Not in values list
            },
        })
        // Returns validation error

6.2 File System Errors

    Permission Errors:
    
        store, err := nanostore.New("/read-only/path/data.json", config)
        if err != nil {
            // Handle permission or path errors
        }

    Lock Timeout:
    
        err := store.Add("title", dimensions)
        if errors.Is(err, nanostore.ErrLockTimeout) {
            // Another process has exclusive access
            // Retry or fail gracefully
        }

7. Best Practices

7.1 Resource Management

    Always Close Stores:
    
        store, err := nanostore.New(path, config)
        if err != nil {
            return err
        }
        defer store.Close() // Ensures proper cleanup

7.2 Error Handling

    Check All Errors:
    
        id, err := store.Add(title, dimensions)
        if err != nil {
            return fmt.Errorf("failed to add document: %w", err)
        }

7.3 Type Safety

    Use Declarative API:
    
        // Good: Type-safe operations
        store, err := nanostore.NewFromType[TaskItem](path)
        results, err := store.Query().Status("pending").Find()
        
        // Avoid: String-based operations when types are available
        opts.Filters["status"] = "pending" // No compile-time checking

7.4 Performance

    Batch Related Operations:
    
        // Good: Single query for multiple documents
        documents, err := store.Query().
            Status("pending").
            Priority("high").
            Find()
        
        // Avoid: Multiple individual queries
        for _, id := range ids {
            doc, err := store.Get(id) // Inefficient
        }

    Use Appropriate Filters:
    
        // Good: Specific filters reduce result set
        results, err := store.Query().
            Status("pending").
            Activity("active").
            ParentID(parentID).
            Find()
        
        // Avoid: Over-fetching then filtering in code
        all, err := store.Query().Find() // Gets everything
        // ... filter in Go code

8. Examples

8.1 Todo Application

    Complete todo management example showing hierarchical tasks, status
    transitions, and search functionality. See docs/in-depth-guide.txt
    for detailed implementation.

8.2 Note Taking

    Hierarchical note organization with categories and tags:
    
        type Note struct {
            nanostore.Document
            Category string `values:"personal,work,ideas" default:"personal"`
            Status   string `values:"draft,published,archived" default:"draft"`
            ParentID string `dimension:"parent_id,ref"`
            
            Tags      string
            Content   string
            Author    string
            CreatedBy string
        }

8.3 Project Management

    Task tracking with priorities and assignments:
    
        type ProjectTask struct {
            nanostore.Document
            Status     string `values:"todo,progress,review,done" prefix:"done=d"`
            Priority   string `values:"low,medium,high,critical" prefix:"critical=!,high=h"`
            ProjectID  string `dimension:"project_id,ref"`
            
            AssignedTo  string
            DueDate     time.Time
            Estimate    int
            Complexity  string
        }

This reference covers the complete nanostore API surface. For implementation
details and advanced usage patterns, see the technical architecture documentation
and in-depth usage guide.