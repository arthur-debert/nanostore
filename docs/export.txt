Nanostore Export Functionality

1. Overview

    The export feature allows applications to create zip archives containing complete nanostore data. The export creates a structured archive with a database file and individual content files for each document.

    Export supports filtering by document IDs, dimension filters, or exporting all documents. The resulting archive contains all information needed to recreate the complete dataset.

2. Export Structure

    Each export creates a zip file containing:
    
    - db.json: Complete database representation with all documents and metadata
    - Individual .txt files: One file per document containing the document body
    
    File naming follows the pattern: <uuid>-<order>-<title>.txt
    
    Example archive contents:
        db.json
        abc123-1-buy-groceries.txt
        def456-1-1-milk.txt
        ghi789-h2-important-task.txt

3. Programming Interface

3.1 Basic Export

    Export all documents to a temporary directory:
    
        archivePath, err := nanostore.Export(store, nanostore.ExportOptions{})
        
    Export to a specific path:
    
        err := nanostore.ExportToPath(store, nanostore.ExportOptions{}, "/path/to/export.zip")

3.2 Filtered Export

    Export specific documents by ID:
    
        options := nanostore.ExportOptions{
            IDs: []string{"1", "c2", "1.3"},
        }
        archivePath, err := nanostore.Export(store, options)
        
    Export by dimension filters:
    
        options := nanostore.ExportOptions{
            DimensionFilters: map[string]interface{}{
                "status": "completed",
                "priority": "high",
            },
        }
        archivePath, err := nanostore.Export(store, options)

3.3 Export Metadata

    Preview export contents without creating an archive:
    
        metadata, err := nanostore.GetExportMetadata(store, options)
        fmt.Printf("Would export %d documents\n", metadata.DocumentCount)
        for _, doc := range metadata.Documents {
            fmt.Printf("  %s -> %s\n", doc.SimpleID, doc.Filename)
        }

4. CLI Integration

4.1 Adding Export to Your CLI

    Applications using Cobra can integrate export functionality:
    
        import "github.com/arthur-debert/nanostore/nanostore"
        
        func main() {
            rootCmd := &cobra.Command{Use: "myapp"}
            
            // Create export command
            exportCmd := nanostore.CreateExportCommand("/path/to/store.json", config)
            rootCmd.AddCommand(exportCmd)
            
            rootCmd.Execute()
        }

4.2 Command Usage

    The generated CLI command supports:
    
        myapp export                    # Export all documents
        myapp export 1 c2              # Export specific documents
        myapp export --output backup.zip # Export to specific file

5. Implementation Details

5.1 Two-Phase Process

    Export operates in two phases for testability:
    
    1. Generate export data structure (JSON representation)
    2. Create zip archive from export data
    
    This design allows comprehensive testing without filesystem operations.

5.2 Filename Generation

    Document filenames are generated with these rules:
    
    - Use document title, sanitized to alphanumeric, dash, underscore
    - Replace spaces with dashes
    - Include hierarchical order prefix from SimpleID
    - Truncate to 40 characters
    - Fall back to document content if no title
    - Use UUID as base identifier

5.3 Timestamp Preservation

    Files in the archive maintain original created/modified timestamps from the document metadata.

6. Testing Export

    The export system includes comprehensive test coverage:
    
    - Filename generation and sanitization
    - Archive creation and extraction
    - Round-trip verification
    - Integration with typed stores
    
    Tests operate primarily on the export data structure, avoiding filesystem dependencies for most test cases.

7. Error Handling

    Common error scenarios:
    
    - Invalid document IDs: Returns clear error messages
    - Store access failures: Propagates underlying store errors
    - Archive creation failures: File system permission or space issues
    - Empty exports: Handled gracefully with informational messages