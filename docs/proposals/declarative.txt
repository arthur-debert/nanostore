DECLARATIVE STORE SPECIFICATION

1. OVERVIEW

Define nanostore configuration through struct tags instead of separate Config objects.
The struct definition becomes the single source of truth for both data model and store behavior.

2. STRUCT TAG SYNTAX

dimension:"name,options..."   - Dimension configuration (comma-separated)
  - name: Explicit dimension name (optional, defaults to snake_case of field name)
  - ref: Marks hierarchical reference field
  - Example: dimension:"parent_id,ref"

values:"val1,val2,..."       - Enumerated values for validation
prefix:"value=p,..."         - ID prefixes for specific values  
default:"value"              - Default value when not specified
dimension:"-"                - Exclude field from dimensions

Field name to dimension name conversion:
- ParentID -> parent_id
- Status -> status
- HTTPCode -> http_code

3. TYPE DETECTION RULES

string type:
- With values tag → Enumerated dimension
- With ref tag → Hierarchical dimension  
- Otherwise → String dimension (not currently in nanostore, for future filtering)

Custom string types (type Status string):
- Treated as enumerated dimension
- values tag required or panic at initialization

Other types:
- Not supported as dimensions in current design

4. API

// Create store from type - returns error for invalid configuration
store, err := nanostore.NewFromType[T](dbPath string) (*TypedStore[T], error)

// TypedStore provides
store.Create(title string, item *T) (string, error)
store.Update(id string, item *T) error  
store.Delete(id string, cascade bool) error
store.Get(id string) (*T, error)
store.Query() *TypedQuery[T]

// TypedQuery provides fluent interface
query.Status(value string)
query.StatusNot(value string)
query.StatusIn(values ...string)
query.ParentID(value string)        // Supports smart ID resolution
query.ParentIDExists()               // Has parent
query.ParentIDNotExists()            // No parent
query.Find() ([]T, error)
query.First() (*T, error)  
query.Get() (*T, error)              // Exactly one or error
query.Count() (int, error)
query.Exists() (bool, error)
query.OrderBy(fields ...string)
query.Limit(n int)
query.Offset(n int)

5. IMPLEMENTATION NOTES

- Build Config once during NewFromType and cache it
- Use runtime reflection only at initialization, not per-query
- Generate query methods map during initialization:
  methodMap map[string]func(q *TypedQuery[T], args ...interface{})
- Return error from NewFromType for invalid configurations
- Query methods are bound to the cached metadata

6. ERROR CASES

- Duplicate dimension names
- Invalid enum values in data
- Missing required tags (e.g., values for enum)
- Invalid ref field configuration
- Type registration errors

7. EXAMPLE: NESTED TODO MANAGER

type TodoItem struct {
    nanostore.Document
    Status   string `values:"pending,in_progress,completed" prefix:"completed=c" default:"pending"`
    Priority string `values:"low,medium,high" prefix:"high=h" default:"medium"`
    ParentID string `dimension:"parent_id,ref"`
}

// Alternatively, using implicit dimension naming:
type TodoItem struct {
    nanostore.Document
    Status   string `values:"pending,in_progress,completed" prefix:"completed=c" default:"pending"`  
    Priority string `values:"low,medium,high" prefix:"high=h" default:"medium"`
    ParentID string `dimension:",ref"`  // Empty name = use snake_case(ParentID) = parent_id
}

// Create store
store, err := nanostore.NewFromType[TodoItem](":memory:")

// Create root task
root, err := store.Create("Build feature", &TodoItem{
    Priority: "high",
})

// Create subtasks
sub1, err := store.Create("Write tests", &TodoItem{
    Priority: "high",
    ParentID: root, // Uses smart ID resolution
})

sub2, err := store.Create("Update docs", &TodoItem{
    Priority: "medium",
    ParentID: root,
})

// Query examples
// Find all high priority incomplete tasks
tasks, err := store.Query().
    PriorityIn("high").
    StatusNot("completed").
    Find()

// Find root tasks only
roots, err := store.Query().
    ParentIDNotExists().
    Find()

// Find subtasks of specific parent
subtasks, err := store.Query().
    ParentID(root).
    Find()

// Get specific task by user-facing ID
task, err := store.Get("h1.2") // High priority root task's second child

// Update task
task.Status = "completed"
err = store.Update(task.UUID, task)

// Complete all subtasks
subs, _ := store.Query().ParentID(root).Find()
for _, sub := range subs {
    sub.Status = "completed"
    store.Update(sub.UUID, &sub)
}