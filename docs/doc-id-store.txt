Title: Proposal for a Configurable Document and ID Store: nanostore

Summary:
      
      This document proposes a new library that provides configurable, user-facing ID 
      generation for document storage systems. The library will be built on SQLite and 
      allow applications to define their own ID partitioning dimensions (status, priority, 
      team, etc.) rather than being locked into hardcoded bucketing logic. This approach 
      aims to provide a reusable foundation for CLI tools and interactive applications 
      that need human-friendly, contiguous IDs.

1. Problem Statement:
      
      Current document storage solutions with user-facing IDs suffer from several issues:

      1.1.  Hardcoded Dimensions: Existing solutions hardcode specific partitioning logic 
            (e.g., status="pending" vs "completed"). Applications with different business 
            domains (priority levels, team assignments, project phases) cannot reuse the 
            same ID generation logic.

      1.2.  User Experience: Infinitely incrementing, non-contiguous IDs (e.g., 1434, 1436)
            are user-unfriendly for CLI tools. Users expect lists to start at 1 within 
            meaningful contexts.

      1.3.  Architectural Complexity: The decoupling of ID management from document storage
            creates significant complexity. Applications must orchestrate multiple components,
            fetching data, filtering and sorting it, then generating appropriate IDs.

      1.4.  Inflexible ID Formats: Fixed ID formats (like "c1" for completed items) don't 
            adapt to different domain vocabularies. A project management tool might want 
            "h1" for high-priority items, while a support system wants "r1" for resolved 
            tickets.

      1.5.  Mixed Dimension Types: Real applications need both enumerated dimensions 
            (status, priority) and relational dimensions (parent-child, project-membership).
            Current systems typically handle only one pattern well.

2. Proposed Solution:
      
      The proposal is to create a configurable document and ID store library that allows
      applications to define their own ID partitioning dimensions at initialization time.

      Key Components:
      2.1.  Dimension Configuration: Applications specify their ID bucketing requirements
            through a declarative configuration, defining both enumerated dimensions 
            (status, priority, team) and relational dimensions (parent-child hierarchies, 
            project membership).

      2.2.  Dynamic Schema Generation: The library automatically generates appropriate
            SQLite schema based on the configured dimensions, adding necessary columns,
            indexes, and constraints.

      2.3.  Configurable ID Generation: SQL queries with ROW_NUMBER() partitioning are
            generated dynamically based on the dimension configuration, allowing flexible
            ID formats like "h2.1.r3" (high-priority, parent.child, resolved).

      2.4.  Flexible ID Resolution: The parsing and resolution logic adapts to the 
            configured dimensions, handling arbitrary prefix combinations and hierarchical
            structures.

3. Key Design Principles:

      3.1.  The ID is a Property of the View, Not the Data.

      The core principle is that the contiguous, user-facing integer ID (e.g., "1", "2",
            "c1") is not a persistent attribute of a document. It is a transient property
            calculated for a specific view of the data at a specific time. The only stable,
            persistent identifier for a document will be an internal UUID. This eliminates the
            need for complex "re-indexing" operations on every write. Writes (add, complete,
            edit) become simple INSERTs or UPDATEs. Reads (list, search) will generate the IDs on
            the fly.

      3.2.  Declarative Queries over Imperative Logic.

      We will leverage the power of SQL to handle data manipulation. The generation of
            contiguous IDs for different dimensions (partitions) is a perfect use case for SQL
            window functions, specifically `ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)`. A
            single, declarative SQL query can replace the current multi-step imperative process
            of fetching, filtering, sorting, and generating IDs in Go.

      3.3.  Cohesion of Data and Logic.
      
      By placing the ID generation logic in the same component that manages the data, we
            create a highly cohesive system. The application's role is simplified to requesting a
            view and rendering the result, leading to cleaner, more maintainable code in the
            `cmd` layer.

4. Dimension Types and Configuration:

      4.1. Enumerated Dimensions:
      Predefined value sets with optional prefix mapping for ID generation.
      
      Example: Status dimension with values ["pending", "completed", "blocked"]
      - "pending" items get IDs: 1, 2, 3...
      - "completed" items get IDs with "c" prefix: c1, c2, c3...  
      - "blocked" items get IDs with "b" prefix: b1, b2, b3...

      4.2. Hierarchical Dimensions:
      Self-referencing relationships that create parent-child structures.
      
      Example: Parent dimension creating nested structures
      - Root items: 1, 2, 3...
      - Children of item 1: 1.1, 1.2, 1.3...
      - Grandchildren of 1.2: 1.2.1, 1.2.2...

      4.3. Configuration API:
      ```go
      type DimensionConfig struct {
          Name     string                 // Database column name
          Type     DimensionType          // Enumerated or Hierarchical
          Values   []string               // Valid values (enumerated only)
          Prefixes map[string]string      // Value -> prefix mapping
          RefField string                 // Referenced field (hierarchical only)
      }

      config := Config{
          Dimensions: []DimensionConfig{
              {
                  Name: "status",
                  Type: Enumerated,
                  Values: []string{"pending", "completed", "blocked"},
                  Prefixes: map[string]string{
                      "completed": "c",
                      "blocked":   "b",
                  },
              },
              {
                  Name: "priority", 
                  Type: Enumerated,
                  Values: []string{"low", "normal", "high"},
                  Prefixes: map[string]string{"high": "h"},
              },
              {
                  Name: "parent",
                  Type: Hierarchical,
                  RefField: "parent_uuid",
              },
          },
      }
      ```

5. Dynamic Schema Generation:

      The library generates SQLite schema based on dimension configuration:

      Base table (always present):
      ```sql
      CREATE TABLE documents (
          uuid TEXT PRIMARY KEY,
          title TEXT NOT NULL,
          body TEXT DEFAULT '',
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL
      );
      ```

      Additional columns per dimension:
      ```sql
      -- For enumerated dimensions
      ALTER TABLE documents ADD COLUMN status TEXT DEFAULT 'pending' 
          CHECK (status IN ('pending', 'completed', 'blocked'));
      ALTER TABLE documents ADD COLUMN priority TEXT DEFAULT 'normal'
          CHECK (priority IN ('low', 'normal', 'high'));
      
      -- For hierarchical dimensions  
      ALTER TABLE documents ADD COLUMN parent_uuid TEXT
          REFERENCES documents(uuid) ON DELETE CASCADE;
      ```

      Indexes for performance:
      ```sql
      CREATE INDEX idx_documents_status ON documents(status, created_at);
      CREATE INDEX idx_documents_priority ON documents(priority, created_at);
      CREATE INDEX idx_documents_parent ON documents(parent_uuid, created_at);
      ```

6. API Design Sketch:

      ```go
      package nanostore

      // Configuration for dimension-aware ID generation
      type Config struct {
          Dimensions []DimensionConfig
      }

      type DimensionConfig struct {
          Name     string
          Type     DimensionType
          Values   []string
          Prefixes map[string]string
          RefField string
      }

      type DimensionType int
      const (
          Enumerated DimensionType = iota
          Hierarchical
      )

      // The main library handle
      type Store struct {
          db     *sql.DB
          config Config
      }

      // Initialization with configuration
      func NewWithConfig(dbPath string, config Config) (*Store, error) {
          // Validates configuration
          // Generates and applies schema migrations
          // Returns configured store
      }

      // Flexible filtering based on configured dimensions
      type ListOptions struct {
          Filters map[string]interface{} // dimension_name -> filter_value
          Search  string
      }

      // The object returned to the application, including generated ID
      type Document struct {
          UUID         string
          UserFacingID string
          Title        string
          Body         string
          Dimensions   map[string]interface{} // dimension_name -> value
          CreatedAt    time.Time
          UpdatedAt    time.Time
      }

      // Primary read method
      func (s *Store) List(opts ListOptions) ([]Document, error) {
          // Builds dynamic SQL based on configured dimensions
          // Generates appropriate ROW_NUMBER() partitioning
          // Returns documents with context-appropriate IDs
      }

      // Configurable ID resolution
      func (s *Store) ResolveUUID(userFacingID string) (string, error) {
          // Parses ID according to configured dimensions
          // Handles arbitrary prefix combinations
          // Supports configured hierarchical structures
      }

      // Flexible document creation
      func (s *Store) Add(title string, dimensions map[string]interface{}) (string, error) {
          // Validates dimension values against configuration
          // Inserts with appropriate dimension column values
      }

      // Dimension-aware updates
      func (s *Store) Update(uuid string, req UpdateRequest) error {
          // Updates both core fields and dimension values
          // Validates dimension changes
      }

      type UpdateRequest struct {
          Title      *string
          Body       *string
          Dimensions map[string]interface{} // dimension updates
      }
      ```

7. Configurable ID Resolution:

      ID resolution adapts to the configured dimensions and prefixes.

      Example with configuration: status=["pending","completed","blocked"], priority=["low","high"], parent=hierarchical

      Input ID: "h2.1.b3" (high-priority, parent.child, blocked)

      Resolution process:
      7.1.  Parse prefix "h" -> maps to priority="high" based on configuration
      7.2.  Find root item #2 with priority="high" 
      7.3.  Parse "1" -> find child #1 of that parent
      7.4.  Parse prefix "b" -> maps to status="blocked"
      7.5.  Find blocked item #3 within that parent context
      7.6.  Return the UUID of the resolved document

      The parsing logic is generated based on the dimension configuration, handling
      arbitrary prefix combinations and hierarchical depth.

8. Implementation Benefits:

      - Reusable across different business domains (todos, tickets, projects, etc.)
      - Configurable ID formats adapt to domain vocabulary  
      - Declarative configuration eliminates hardcoded partitioning logic
      - Automatic schema generation reduces setup complexity
      - SQL-based implementation provides performance and data integrity
      - Single library handles both storage and ID concerns

      Potential Considerations:
      - Configuration complexity for applications with many dimensions
      - SQL generation complexity for arbitrary dimension combinations
      - CGO dependency via mattn/go-sqlite3 affects cross-compilation
      - Performance characteristics with deep hierarchies and many dimensions

9. Implementation Planning:

      Phase 1: Core Configuration System
      - Define dimension configuration types and validation
      - Implement dynamic schema generation
      - Create configuration-based SQL query generation

      Phase 2: ID Generation and Resolution  
      - Build configurable ROW_NUMBER() partitioning
      - Implement dynamic ID parsing and resolution
      - Handle arbitrary prefix combinations

      Phase 3: Integration and Testing
      - Comprehensive test suite with multiple dimension configurations
      - Performance testing with various scenarios
      - Backward compatibility layer for existing hardcoded systems

      Phase 4: Documentation and Examples
      - Configuration examples for common use cases
      - Migration guide from hardcoded to configurable systems
      - Performance tuning recommendations 