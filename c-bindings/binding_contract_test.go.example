package main

// This file documents the expected behavior that language bindings should test
// It uses the Go API directly to establish the contract

import (
	"encoding/json"
	"testing"

	"github.com/arthur-debert/nanostore/nanostore"
)

// TestBindingContract_BasicConfig tests the basic configuration that bindings should support
func TestBindingContract_BasicConfig(t *testing.T) {
	// Test 1: Simple enumerated dimension config
	t.Run("SimpleConfig", func(t *testing.T) {
		store, err := nanostore.New(":memory:", nanostore.Config{
			Dimensions: []nanostore.DimensionConfig{
				{
					Name:         "status",
					Type:         nanostore.Enumerated,
					Values:       []string{"active", "archived"},
					Prefixes:     map[string]string{"archived": "a"},
					DefaultValue: "active",
				},
			},
		})
		if err != nil {
			t.Fatalf("Failed to create store: %v", err)
		}
		defer store.Close()

		// Should succeed
		if store == nil {
			t.Fatal("Expected valid store")
		}
	})

	// Test 2: Todo-style config (what todoConfig() should produce)
	t.Run("TodoConfig", func(t *testing.T) {
		store, err := nanostore.New(":memory:", nanostore.Config{
			Dimensions: []nanostore.DimensionConfig{
				{
					Name:         "status",
					Type:         nanostore.Enumerated,
					Values:       []string{"pending", "completed"},
					Prefixes:     map[string]string{"completed": "c"},
					DefaultValue: "pending",
				},
				{
					Name:     "parent",
					Type:     nanostore.Hierarchical,
					RefField: "parent_uuid",
				},
			},
		})
		if err != nil {
			t.Fatalf("Failed to create store with todo config: %v", err)
		}
		defer store.Close()
	})

	// Test 3: Example config (what exampleConfig() should produce)
	t.Run("ExampleConfig", func(t *testing.T) {
		store, err := nanostore.New(":memory:", nanostore.Config{
			Dimensions: []nanostore.DimensionConfig{
				{
					Name:         "category",
					Type:         nanostore.Enumerated,
					Values:       []string{"default", "archived"},
					Prefixes:     map[string]string{"archived": "a"},
					DefaultValue: "default",
				},
				{
					Name:     "parent",
					Type:     nanostore.Hierarchical,
					RefField: "parent_uuid",
				},
			},
		})
		if err != nil {
			t.Fatalf("Failed to create store with example config: %v", err)
		}
		defer store.Close()
	})
}

// TestBindingContract_CRUD tests basic CRUD operations
func TestBindingContract_CRUD(t *testing.T) {
	store, err := nanostore.New(":memory:", nanostore.Config{
		Dimensions: []nanostore.DimensionConfig{
			{
				Name:         "type",
				Type:         nanostore.Enumerated,
				Values:       []string{"user", "product", "task"},
				DefaultValue: "task",
			},
			{
				Name:         "status",
				Type:         nanostore.Enumerated,
				Values:       []string{"active", "archived"},
				DefaultValue: "active",
			},
		},
	})
	if err != nil {
		t.Fatalf("Failed to create store: %v", err)
	}
	defer store.Close()

	// Test Add
	t.Run("Add", func(t *testing.T) {
		uuid, err := store.Add("Test Document", map[string]interface{}{
			"type":   "user",
			"status": "active",
		})
		if err != nil {
			t.Fatalf("Failed to add document: %v", err)
		}
		if uuid == "" {
			t.Fatal("Expected non-empty UUID")
		}
	})

	// Test List
	t.Run("List", func(t *testing.T) {
		// Add some documents first
		store.Add("User 1", map[string]interface{}{"type": "user", "status": "active"})
		store.Add("User 2", map[string]interface{}{"type": "user", "status": "archived"})
		store.Add("Product 1", map[string]interface{}{"type": "product", "status": "active"})

		// List all
		docs, err := store.List(nanostore.ListOptions{})
		if err != nil {
			t.Fatalf("Failed to list documents: %v", err)
		}
		if len(docs) < 3 {
			t.Fatalf("Expected at least 3 documents, got %d", len(docs))
		}

		// List with filters
		userDocs, err := store.List(nanostore.ListOptions{
			Filters: map[string]interface{}{"type": "user"},
		})
		if err != nil {
			t.Fatalf("Failed to list filtered documents: %v", err)
		}
		if len(userDocs) != 2 {
			t.Fatalf("Expected 2 user documents, got %d", len(userDocs))
		}
	})

	// Test Get (bindings implement this as list with ID filter)
	t.Run("Get", func(t *testing.T) {
		uuid, _ := store.Add("Get Test", map[string]interface{}{"type": "task"})

		docs, err := store.List(nanostore.ListOptions{
			Filters: map[string]interface{}{"ids": []string{uuid}},
		})
		if err != nil {
			t.Fatalf("Failed to get document: %v", err)
		}
		if len(docs) != 1 {
			t.Fatal("Expected exactly one document")
		}
		if docs[0].Title != "Get Test" {
			t.Fatal("Wrong document returned")
		}
	})

	// Test Update
	t.Run("Update", func(t *testing.T) {
		uuid, _ := store.Add("Update Test", map[string]interface{}{"status": "active"})

		err := store.Update(uuid, nanostore.UpdateRequest{
			Title: stringPtr("Updated Title"),
			Dimensions: map[string]string{
				"status": "archived",
			},
		})
		if err != nil {
			t.Fatalf("Failed to update document: %v", err)
		}

		// Verify update
		docs, _ := store.List(nanostore.ListOptions{
			Filters: map[string]interface{}{"ids": []string{uuid}},
		})
		if docs[0].Title != "Updated Title" {
			t.Fatal("Title not updated")
		}
		if docs[0].Dimensions["status"] != "archived" {
			t.Fatal("Status not updated")
		}
	})

	// Test Delete
	t.Run("Delete", func(t *testing.T) {
		uuid, _ := store.Add("Delete Test", nil)

		err := store.Delete(uuid, false)
		if err != nil {
			t.Fatalf("Failed to delete document: %v", err)
		}

		// Verify deletion
		docs, _ := store.List(nanostore.ListOptions{
			Filters: map[string]interface{}{"ids": []string{uuid}},
		})
		if len(docs) != 0 {
			t.Fatal("Document not deleted")
		}
	})
}

// TestBindingContract_IDResolution tests ID resolution functionality
func TestBindingContract_IDResolution(t *testing.T) {
	store, err := nanostore.New(":memory:", nanostore.Config{
		Dimensions: []nanostore.DimensionConfig{
			{
				Name:         "status",
				Type:         nanostore.Enumerated,
				Values:       []string{"active", "completed"},
				Prefixes:     map[string]string{"completed": "c"},
				DefaultValue: "active",
			},
		},
	})
	if err != nil {
		t.Fatalf("Failed to create store: %v", err)
	}
	defer store.Close()

	// Add a document
	uuid, _ := store.Add("Test", map[string]interface{}{"status": "active"})

	// Get its user-facing ID
	docs, _ := store.List(nanostore.ListOptions{})
	var userFacingID string
	for _, doc := range docs {
		if doc.UUID == uuid {
			userFacingID = doc.UserFacingID
			break
		}
	}

	// Test resolving user-facing ID back to UUID
	resolvedUUID, err := store.ResolveUUID(userFacingID)
	if err != nil {
		t.Fatalf("Failed to resolve UUID: %v", err)
	}
	if resolvedUUID != uuid {
		t.Fatalf("Expected %s, got %s", uuid, resolvedUUID)
	}

	// Test that Update and Delete work with user-facing IDs
	err = store.Update(userFacingID, nanostore.UpdateRequest{
		Title: stringPtr("Updated via user-facing ID"),
	})
	if err != nil {
		t.Fatalf("Failed to update with user-facing ID: %v", err)
	}

	err = store.Delete(userFacingID, false)
	if err != nil {
		t.Fatalf("Failed to delete with user-facing ID: %v", err)
	}
}

// TestBindingContract_ErrorCases tests error handling
func TestBindingContract_ErrorCases(t *testing.T) {
	store, err := nanostore.New(":memory:", nanostore.Config{
		Dimensions: []nanostore.DimensionConfig{
			{
				Name:         "status",
				Type:         nanostore.Enumerated,
				Values:       []string{"active"},
				DefaultValue: "active",
			},
		},
	})
	if err != nil {
		t.Fatalf("Failed to create store: %v", err)
	}
	defer store.Close()

	t.Run("NonExistentDocument", func(t *testing.T) {
		fakeUUID := "00000000-0000-0000-0000-000000000000"

		// Update non-existent
		err := store.Update(fakeUUID, nanostore.UpdateRequest{Title: stringPtr("New")})
		if err == nil {
			t.Fatal("Expected error for non-existent document")
		}

		// Delete non-existent
		err = store.Delete(fakeUUID, false)
		if err == nil {
			t.Fatal("Expected error for non-existent document")
		}
	})

	t.Run("InvalidUserFacingID", func(t *testing.T) {
		_, err := store.ResolveUUID("invalid.id.format")
		if err == nil {
			t.Fatal("Expected error for invalid user-facing ID")
		}
	})

	t.Run("InvalidDimensionValue", func(t *testing.T) {
		_, err := store.Add("Test", map[string]interface{}{
			"status": "invalid_status",
		})
		if err == nil {
			t.Fatal("Expected error for invalid dimension value")
		}
	})
}

// TestBindingContract_JSONSerialization documents expected JSON formats
func TestBindingContract_JSONSerialization(t *testing.T) {
	// Document the expected JSON format for config
	t.Run("ConfigJSON", func(t *testing.T) {
		config := map[string]interface{}{
			"dimensions": []map[string]interface{}{
				{
					"name":          "status",
					"type":          0, // Enumerated
					"values":        []string{"pending", "completed"},
					"prefixes":      map[string]string{"completed": "c"},
					"default_value": "pending",
				},
				{
					"name":      "parent",
					"type":      1, // Hierarchical
					"ref_field": "parent_uuid",
				},
			},
		}

		jsonBytes, err := json.Marshal(config)
		if err != nil {
			t.Fatalf("Failed to marshal config: %v", err)
		}

		// This is what bindings should send
		t.Logf("Expected config JSON: %s", string(jsonBytes))
	})

	// Document the expected response formats
	t.Run("ResponseFormats", func(t *testing.T) {
		// New store response
		newResponse := map[string]string{"handle": "store_1"}
		t.Logf("New store response: %+v", newResponse)

		// Add response
		addResponse := map[string]string{"uuid": "550e8400-e29b-41d4-a716-446655440000"}
		t.Logf("Add response: %+v", addResponse)

		// Error response
		errorResponse := map[string]string{"error": "document not found"}
		t.Logf("Error response: %+v", errorResponse)

		// List response (array of documents)
		listResponse := []map[string]interface{}{
			{
				"uuid":           "550e8400-e29b-41d4-a716-446655440000",
				"user_facing_id": "1",
				"title":          "Test Document",
				"body":           "",
				"dimensions":     map[string]interface{}{"status": "active"},
				"created_at":     1234567890,
				"updated_at":     1234567890,
			},
		}
		t.Logf("List response: %+v", listResponse)
	})
}

func stringPtr(s string) *string {
	return &s
}