// +build ignore

package main

// #cgo CFLAGS: -I.
// #cgo LDFLAGS: -L. -lnanostore
// #include <stdlib.h>
// #include "libnanostore.h"
import "C"
import (
	"encoding/json"
	"fmt"
	"os"
	"unsafe"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <db_path> <command> [args...]\n", os.Args[0])
		os.Exit(1)
	}

	dbPath := os.Args[1]
	command := os.Args[2]

	// Create store
	cDbPath := C.CString(dbPath)
	defer C.free(unsafe.Pointer(cDbPath))
	
	store := C.NanoStoreNew(cDbPath)
	if store == nil {
		response := map[string]string{"error": "Failed to create store"}
		json.NewEncoder(os.Stdout).Encode(response)
		os.Exit(1)
	}
	defer C.NanoStoreClose(store)

	var result *C.char

	switch command {
	case "add":
		if len(os.Args) < 6 {
			response := map[string]string{"error": "add requires: collection, docType, content, parent"}
			json.NewEncoder(os.Stdout).Encode(response)
			return
		}
		collection := C.CString(os.Args[3])
		docType := C.CString(os.Args[4])
		content := C.CString(os.Args[5])
		parent := C.CString("")
		if len(os.Args) > 6 {
			parent = C.CString(os.Args[6])
		}
		defer C.free(unsafe.Pointer(collection))
		defer C.free(unsafe.Pointer(docType))
		defer C.free(unsafe.Pointer(content))
		defer C.free(unsafe.Pointer(parent))
		
		result = C.NanoStoreAdd(store, collection, docType, content, parent)

	case "get":
		if len(os.Args) < 4 {
			response := map[string]string{"error": "get requires: id"}
			json.NewEncoder(os.Stdout).Encode(response)
			return
		}
		id := C.CString(os.Args[3])
		defer C.free(unsafe.Pointer(id))
		
		result = C.NanoStoreGet(store, id)

	case "update":
		if len(os.Args) < 5 {
			response := map[string]string{"error": "update requires: id, content"}
			json.NewEncoder(os.Stdout).Encode(response)
			return
		}
		id := C.CString(os.Args[3])
		content := C.CString(os.Args[4])
		defer C.free(unsafe.Pointer(id))
		defer C.free(unsafe.Pointer(content))
		
		result = C.NanoStoreUpdate(store, id, content)

	case "delete":
		if len(os.Args) < 4 {
			response := map[string]string{"error": "delete requires: id"}
			json.NewEncoder(os.Stdout).Encode(response)
			return
		}
		id := C.CString(os.Args[3])
		defer C.free(unsafe.Pointer(id))
		
		result = C.NanoStoreDelete(store, id)

	case "list":
		collection := C.CString("")
		docType := C.CString("")
		if len(os.Args) > 3 {
			collection = C.CString(os.Args[3])
		}
		if len(os.Args) > 4 {
			docType = C.CString(os.Args[4])
		}
		defer C.free(unsafe.Pointer(collection))
		defer C.free(unsafe.Pointer(docType))
		
		result = C.NanoStoreList(store, collection, docType, 100, 0)

	case "resolve":
		if len(os.Args) < 4 {
			response := map[string]string{"error": "resolve requires: uuid"}
			json.NewEncoder(os.Stdout).Encode(response)
			return
		}
		uuid := C.CString(os.Args[3])
		defer C.free(unsafe.Pointer(uuid))
		
		result = C.NanoStoreResolve(store, uuid)

	case "generate_id":
		if len(os.Args) < 6 {
			response := map[string]string{"error": "generate_id requires: collection, docType, position"}
			json.NewEncoder(os.Stdout).Encode(response)
			return
		}
		collection := C.CString(os.Args[3])
		docType := C.CString(os.Args[4])
		defer C.free(unsafe.Pointer(collection))
		defer C.free(unsafe.Pointer(docType))
		
		var position int
		fmt.Sscanf(os.Args[5], "%d", &position)
		
		result = C.NanoStoreGenerateID(store, collection, docType, C.int(position))

	default:
		response := map[string]string{"error": fmt.Sprintf("Unknown command: %s", command)}
		json.NewEncoder(os.Stdout).Encode(response)
		return
	}

	if result != nil {
		fmt.Print(C.GoString(result))
		C.NanoStoreFreeString(result)
	} else {
		response := map[string]string{"error": "Operation failed"}
		json.NewEncoder(os.Stdout).Encode(response)
	}
}